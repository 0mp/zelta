#!/usr/bin/awk -f
#
# zmatch - compares a source and target datasets for dataset simiddlarity
#
# usage: zmatch [user@][host:]source/dataset target/dataset
#
# Reports the most recent matching snapshot and the latest snapshot of a volume ant
# its children, which can be useful in various "zfs send" and "zfs rollback" commands.
#
# Child snapshot names are provided relative to the target dataset. For example, when 
# zmatch is called with tank/dataset, tank/dataset/child's snapshots will be reported as
# "/child@snapshot-name"
#
# Specifically:
#   - The latest matching snapshot and child snapshots
#   - Missing child volumes on the destination
#   - Matching snapshot names with different GUIDs
#   - Newer target snapshots not on the source
#
# ENVIRONMENT VARIABLES
#
# ZELTA_PIPE: When set to 1, we provide full snapshot names and simplify the output as
# follows:
#   - No output is provided for an up-to-date match.
#   - A single snapshot indicates the volume is missing on the target.
#   - A tab separated pair of snapshots indicates the out-of-date match and the latest.
#
# ZELTA_DEPTH: Adds "-d $ZELTA_DEPTH" to zfs list commands. Useful for limiting
# replication depth in zpull.

function zfs_list_command(arg, flags) {
	if (!split(arg, snap, ":")) exit
	if (snap[2]) {
		cmdpre = "ssh " snap[1] " "
		snapvol = snap[2];
	} else {
		cmdpre = ""
		snapvol = snap[1]
	}
	vollength = length(snapvol) + 1 # Get dataset length for trimming 
	dataset[arg] = snapvol
	return cmdpre "zfs list " flags " '" snapvol "' 2>&1"
}

BEGIN {
	FS="\t"
	exit_code = 0
	source = ARGV[1]
	target = ARGV[2]
	if ("ZELTA_PIPE" in ENVIRON) { ZELTA_PIPE = ENVIRON["ZELTA_PIPE"] }
	if ("ZELTA_DEPTH" in ENVIRON) { list_snapshot_flags = "-d " ENVIRON["ZELTA_DEPTH"] " " }
	list_snapshot_flags = "-Hroname,guid -Htsnap -Screation " list_snapshot_flags

	# Get snapshots for source
	while  (zfs_list_command(source, list_snapshot_flags) | getline) {
		if (! /@/) {
			print "error: " $0 | "cat 1>&2"
			exit_code = 1
			continue
		}
		thisSnap = substr($1, vollength)
		sendguids[thisSnap] = $2
		split(thisSnap, volSplit, "@")
		thisSubVol = volSplit[1]
		if (!(sendVolCount[thisSubVol]++)) {
			sendLatest[thisSubVol] = thisSnap
			sendOrder[++sendNum] = thisSubVol
		}
		sendsnaps[thisSubVol volCount[thisSubVol]] = thisSnap
	}
	close(zfs_list_command(source))

	# Get snapshots for destination
	thisSnap =""
	while  (zfs_list_command(target, list_snapshot_flags) | getline) {
		if (/dataset does not exist/) { continue }
		else if (! /@/) {
			print "error: " $0 | "cat 1>&2"
			exit_code = 1
			continue
		}
		thisSnap = substr($1, vollength)
		recvguids[thisSnap] = $2
		split(thisSnap, volSplit, "@")
		thisSubVol = volSplit[1]
		thisSnapshot = volSplit[2]
		if (matches[thisSubVol]) { continue }
		recvVolCount[thisSubVol]++
		if (sendguids[thisSnap]) {
			if (sendguids[thisSnap] == recvguids[thisSnap]) {
				matches[thisSubVol]++
				if (thisSnap == sendLatest[thisSubVol]) {
					if (!ZELTA_PIPE) { print "target has latest source snapshot: " thisSnap }
				} else if (guidError[thisSubVol]) {
					print "latest common snapshot: " thisSnap | "cat 1>&2"
				} else if (recvVolCount[thisSubVol] == 1) {
					if (!ZELTA_PIPE) { printf "match: " }
					printf "@" thisSnapshot "\t"
					if (ZELTA_PIPE) { printf dataset[source] }
					else { printf "\tsource latest: " }
					printf sendLatest[thisSubVol]
					if (ZELTA_PIPE) { printf "\t" dataset[target] thisSubVol }
					print ""
				}
				continue
			} else {
				print "guid mismatch on: " thisSnap | "cat 1>&2"
				guidError[thisSubVol]++
			}
		} else {
			if (!(matchError[thisSubVol]++)) {
				if (sendVolCount[thisSubVol]) {
					print "target snapshot not on source: " thisSnap | "cat 1>&2"
				} else {
					# Old backups might have old child volumes, we'll suppress those in script mode
					if (!ZELTA_PIPE) { print "child volume not on source: " thisSnap | "cat 1>&2" }
				}
			}
		}
	}
	close(zfs_list_command(target))

	if (! thisSnap) {
		parent = dataset[target]
		gsub(/\/[^\/]+$/, "", parent)
		zfs_list_command(parent, "-o name") | getline
		no_parent = /dataset does not exist/;
		if (! ZELTA_PIPE) { print "target does not exist" }
		if (no_parent) {
			print ZELTA_PIPE ? parent : "target's parent does not exist"
		}
	}

	# List latest source snapshots for volumes not on the target
	for (i = 1; i <= sendNum; i++) {
		subvol = sendOrder[i]
		if (!(subvol in recvVolCount)) {
			if (ZELTA_PIPE) { printf dataset[source] }
			else { printf "source only snapshot: " }
		printf sendLatest[subvol]
		if (ZELTA_PIPE) { printf "\t" dataset[target] subvol }
		print ""
		}
	}
	exit exit_code
}
